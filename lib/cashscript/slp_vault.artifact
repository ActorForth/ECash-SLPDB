{
  "contractName": "SlpVault",
  "constructorInputs": [
    {
      "name": "pkh",
      "type": "bytes20"
    }
  ],
  "abi": [
    {
      "name": "sweep",
      "covenant": true,
      "inputs": [
        {
          "name": "outputs",
          "type": "bytes"
        },
        {
          "name": "pk",
          "type": "pubkey"
        },
        {
          "name": "s",
          "type": "sig"
        }
      ]
    },
    {
      "name": "revoke",
      "covenant": true,
      "inputs": [
        {
          "name": "outputs",
          "type": "bytes"
        },
        {
          "name": "prevTxn0",
          "type": "bytes"
        },
        {
          "name": "prevTxn1_pk",
          "type": "bytes"
        },
        {
          "name": "prevTxn2",
          "type": "bytes"
        },
        {
          "name": "s",
          "type": "sig"
        }
      ]
    }
  ],
  "bytecode": "OP_OVER OP_0 OP_NUMEQUAL OP_IF OP_2 OP_PICK OP_SIZE 34 OP_SUB OP_SPLIT OP_NIP OP_8 OP_SPLIT OP_4 OP_SPLIT OP_NIP 20 OP_SPLIT OP_DROP OP_5 OP_PICK OP_HASH256 OP_EQUALVERIFY OP_4 OP_SPLIT OP_DROP OP_BIN2NUM 2202 OP_LESSTHANOREQUAL OP_IF OP_3 OP_PICK OP_8 OP_SPLIT OP_DROP 0000000000000000 OP_EQUALVERIFY OP_ENDIF OP_3 OP_PICK OP_4 OP_ROLL OP_SIZE OP_NIP OP_2 OP_SUB OP_SPLIT OP_NIP 88ac OP_EQUALVERIFY OP_3 OP_PICK OP_HASH160 OP_EQUALVERIFY OP_2SWAP OP_2DUP OP_SWAP OP_SIZE OP_1SUB OP_SPLIT OP_DROP OP_5 OP_ROLL OP_SHA256 OP_ROT OP_CHECKDATASIGVERIFY OP_CHECKSIG OP_NIP OP_ELSE OP_SWAP OP_1 OP_NUMEQUALVERIFY OP_OVER 44 OP_SPLIT OP_NIP 24 OP_SPLIT OP_SIZE 34 OP_SUB OP_SPLIT OP_NIP OP_8 OP_SPLIT OP_4 OP_SPLIT OP_NIP 20 OP_SPLIT OP_DROP OP_SWAP OP_4 OP_SPLIT OP_DROP OP_BIN2NUM 2202 OP_LESSTHANOREQUAL OP_IF OP_DUP OP_5 OP_PICK OP_HASH256 OP_EQUALVERIFY OP_4 OP_PICK OP_8 OP_SPLIT OP_DROP 0000000000000000 OP_EQUALVERIFY OP_ENDIF OP_5 OP_ROLL OP_6 OP_PICK OP_CAT OP_7 OP_ROLL OP_CAT OP_HASH256 OP_ROT 20 OP_SPLIT OP_DROP OP_EQUALVERIFY OP_2ROT OP_2DUP OP_SWAP OP_SIZE OP_1SUB OP_SPLIT OP_DROP OP_6 OP_ROLL OP_SHA256 OP_ROT OP_CHECKDATASIGVERIFY OP_CHECKSIG OP_NIP OP_NIP OP_NIP OP_ENDIF",
  "source": "pragma cashscript 0.5.3;\n\n// SlpVault 1.0\n// -----\n// \n// The purpose of this contract is to avoid accidentally burning of SLP tokens when \n// sending tokens to p2pkh addresses belonging to users who are not using an SLP compatible\n// wallet. Non-SLP wallets will accidentally burn SLP tokens so we normally need a compatibility\n// signal before sending.  This signal is normally in the form of use of the \"simpleledger:\"\n// address encoding format.\n//\n// This contract provides a safe way to send any p2pkh address SLP tokens without the need\n// for such a wallet compatibility signal before sending.  Any SLP wallet can be updated to check\n// the balances of their SLP Vault address for each respective p2pkh address.  If any balances are\n// found on the SLP Vault address, the private key for the p2pkh address can be used to sweep\n// the vault into the user's wallet.\n//\n// Block explorers can be updated to display SLP Vault token balances after a user enters\n// a P2PKH type address. The block explorers can also inform users with instructions on which wallets\n// can provide access to the SLP Vault balance so they can sweep the tokens to a normal SLP wallet.\n//\n// The other major benefit this contract provides the ability for senders to recover tokens after\n// sending at any time until the receiver has moved the coin.  To perform a revoke, the original \n// sender needs to include the original sending transaction in three chunks.  The middle chunk should\n// represent the public key of the p2pkh address the coin should be sent to.\n//\n// WARNING: The revoke feature will not work if the original send transaction is larger than 520 bytes\n// due to the script stack item size limitation.  In this case, only the sweep would be possible.\n//\n// WARNING: The byte code for this contract could change with different cashscript compiler versions.\n// Since our intent is to standardize this SLP Vault 1.0 byte code across wallets and block explorers,\n// this contract should not be recompiled when used.  Instead the .artifact file containing the \n// correct byte code should be loaded when used with the cashscript SDK.  For this reason, we have placed\n// \"DO NOT COMPILE, SEE COMMENTS ABOVE\" within the script contract to prevent users from using this file\n// directly in cashscript SDK workflows.\n//\ncontract SlpVault(bytes20 pkh) {\n    // Sweep\n    // -----\n    // Spend funds from slp vault\n    //\n    // outputs  - transaction hashOutputs preimage\n    //\n    // pubkey   - the pubkey of the pkh for this vault\n    //\n    // sig      - a signature from above pubkey for this txn\n    //\n    function sweep(bytes outputs, pubkey pk, sig s) {\n//DO NOT COMPILE, SEE COMMENTS ABOVE\n\n        require(tx.hashOutputs == hash256(outputs));\n\n        // check if input value is 546 satoshis, indicating possible SLP, require some op_return\n        if (int(tx.value.split(4)[0]) <= 546) {\n            require(outputs.split(8)[0] == 0x0000000000000000);\n        }\n\n        // check for output to any p2pkh, \n        // this helps prevent accidental send to single op_return output\n        require(outputs.split(outputs.length - 2)[1] == 0x88ac);\n\n        // check for the p2pkh owner\n        require(hash160(pk) == pkh);\n        require(checkSig(s, pk));\n    }\n\n    // Revoke \n    // -----\n    // retrieves a coin at any time before the slp vault owner sweeps the coin\n    //\n    // outputs      - transaction hashOutputs preimage\n    //\n    // prevTxn0     - the front part of previous transaction\n    //\n    // prevTxn1_pk  - the public key, middle part of the previous transaction's signatures\n    //\n    // prevTxn2     - the back part of the previous transaction\n    //\n    // sig          - a signature from above pubkey needed for spending this coin\n    //\n    function revoke(bytes outputs, bytes prevTxn0, bytes prevTxn1_pk, bytes prevTxn2, sig s) {\n\n        // check if input value is 546 satoshis, indicating possible SLP, require some OP_RETURN\n        if (int(tx.value.split(4)[0]) <= 546) {\n            require(tx.hashOutputs == hash256(outputs));\n            require(outputs.split(8)[0] == 0x0000000000000000);\n        }\n\n        // check the txid matches outpoint txid\n        bytes32 txid = hash256(prevTxn0 + prevTxn1_pk + prevTxn2);\n        require(tx.outpoint.split(32)[0] == txid);\n\n        // check for output to any p2pkh, \n        // this helps prevent accidental send to single op_return output\n        //require(outputs.split(outputs.length - 2)[1] == 0x88ac);\n\n        // sig check, accept any pubkey within the original transaction\n        require(checkSig(s, pubkey(prevTxn1_pk)));\n    }\n}",
  "compiler": {
    "name": "cashc",
    "version": "0.5.3"
  },
  "updatedAt": "2020-10-21T15:42:12.249Z"
}